import os
import sys
import json
import random
import shutil
from enum import IntEnum
from datetime import datetime, timedelta

from aiohttp import web

import config


redis = {}
# for test purpose
redis['folder:1'] = {'identity':'1', 'created_time':datetime.now().isoformat(), 'current_size':0}
redis['messages:1'] = []


def format_size(num, suffix='B'):
    for unit in ['', 'K','M','G','T','P','E','Z']:
        if abs(num) < 1000.0:
            return '%.1f%s%s' % (num, unit, suffix)
        num /= 1000.0
    return '%.1f%s%s' % (num, 'Yi', suffix)


class MsgType(IntEnum):
    TEXT = 0
    FILE = 1


class Message(dict): 
    """To make this class serializable, I create a dict like class
    checkout https://stackoverflow.com/a/5021467/6088837
    """
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__

    def __init__(self, type, date, data, size, sender):
        self.type = type
        self.date = datetime.isoformat(date) if isinstance(date, datetime) else date
        self.data = data
        self.size = size
        self.sender = sender

    def format_for_view(self):
        d = dict(self)
        d['date'] = datetime.fromisoformat(self.date).strftime("%m-%d %H:%M")
        d['size'] = format_size(self.size)
        return d


class Folder:
    def __init__(self,
                 identity,
                 created_time=None,
                 age=config.AGE,
                 speed_limit=2**10,
                 storage_limit=config.STORAGE_PER_FOLDER,
                 current_size=0,
                 path=None,
                 **kwargs):
        # folder id is a random passcode generated by client and is never sent to the server
        # instead, only the hash of the folder id is passed to the server in each request 
        # and stored as the identity of this folder
        self.identity = identity
        self.created_time = datetime.now().isoformat() if created_time is None else created_time
        self.age = age
        self.speed_limit = speed_limit
        self.storage_limit = storage_limit
        self.current_size = current_size
        self.path = path
        if path is None:
            self.path = self._path(self.identity) 
            shutil.rmtree(self.path, ignore_errors=True)
            os.makedirs(self.path)
        # hold the current active connections
        self.connections = set()

    @property
    def usage_percentage(self):
        return 100 * (self.current_size / self.storage_limit)

    @property
    def expire_at(self):
        return datetime.fromisoformat(self.created_time) + timedelta(days=self.age)
    
    def format_for_view(self):
        return {
            'created_time': self.created_time,
            'age': self.age,
            'storage_limit': format_size(self.storage_limit),
            'current_size': format_size(self.current_size),

            'expire_at': self.expire_at.strftime('%m-%d %H:%M'),
            'usage_percentage': '{:.1f}%'.format(self.usage_percentage)
        }

    @classmethod
    def fetch(cls, identity):
        folder_key, _ = cls._keys(identity)
        folder_info_dict = redis.get(folder_key)
        if folder_info_dict:
            folder = Folder(**folder_info_dict)
            if datetime.now() > folder.expire_at:
                log.info('Folder expired')
                return None
            else:
                return folder
        else:
            return None

    @staticmethod
    def _path(identity):
        """Generate the relative path of a new Folder
        """
        return os.path.join(
            config.UPLOAD_ROOT_DIRECTORY,
            str(random.randint(1, config.UPLOAD_SECOND_DIRECTORY_RANGE)),
            identity)

    @staticmethod
    def _keys(identity):
        return 'folder:%s' % identity, 'messages:%s' % identity

    async def save(self, msg):
        """Save the message in this folder
        """
        folder_key, msg_key = self._keys(self.identity)
        # enqueue
        redis[msg_key].append(json.dumps(msg))
        # upload storage size
        redis[folder_key]['current_size'] += msg.size
        # todo: the operations above should be in a transaction

    async def retrieve(self, offset):
        if offset < 0:
            raise web.HTTPBadRequest
        _, msg_key = self._keys(self.identity)
        queue = redis[msg_key]
        total = len(queue)
        if offset >= total:
            # offset > total occurs when the folder is renewed in the server
            return []
        msgs_json = queue[-(total-offset):]
        return [Message(**json.loads(m)) for m in msgs_json]
  
    @classmethod
    async def signup(cls, identity):
        if await cls.exists(identity):
            # Anti brute force must be employed to disable this exploitation
            raise web.HTTPConflict(text='Identity exists, please try again!')
        if False:
            raise web.HTTPInsufficientStorage(text='Disk is full, please contact the admin! Thanks.')
        folder = cls(identity)
        folder_key, msg_key = cls._keys(identity)
        redis[folder_key] = folder.__dict__
        redis[msg_key] = []
        return True

    @classmethod
    async def exists(cls, identity):
        folder_key, _ = cls._keys(identity)
        return folder_key in redis
